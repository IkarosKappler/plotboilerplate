/**
 * Calculate the inset of any non-self-overlapping polygon.
 *
 * The polygon may be
 *  - convex or non-convex
 *  - self-intersecting
 *
 * The algorithms will
 *  - first construct a general offset polygon which may be corrupt due to ouf-of-bounds or in illegal-area problems.
 *  - then dissect the possibly self-intersecting inset polygon into separate simple polygons.
 *  - then detect for each if it's out of bounds or in some illegal area.
 *  - keeping only the valid ones.
 *
 * @required sutherlandHodgman
 * @required splitPolygonToNonIntersecting
 *
 * @author   Ikaros Kappler
 * @date     2024-11-04 Ported the script to a class.
 * @modified 2024-12-02 Ported to Typescript.
 */

import { Line } from "../../Line";
import { Polygon } from "../../Polygon";
import { Vector } from "../../Vector";
import { Vertex } from "../../Vertex";
import { XYCoords } from "../../interfaces";
import { clearDuplicateVertices } from "./clearDuplicateVertices";
import { splitPolygonToNonIntersecting } from "./splitPolygonToNonIntersecting";
import { sutherlandHodgman } from "./sutherlandHodgman";

// import { GreinerHorman } from "greiner-hormann-typescript";
// import DEBUG from "debug";

export interface IPolygonInsetOptions {
  innerPolygonOffset: number;
  maxPolygonSplitDepth?: number;
  intersectionEpsilon?: number;
}

export class PolygonInset {
  /**
   * The polygon to work with.
   */
  readonly polygon: Polygon;

  /**
   * The original polygon as a sequence of line objects. This is easier to use than a list of points.
   */
  originalPolygonLines: Array<Line> = [];

  /**
   * The simple inset lines, directly generated by offsetting the original polygon lines by the given amount.
   */
  insetLines: Array<Line> = [];

  /**
   * The cropped inset lines that makes up the first direct iteration of the inset polygon.
   * This one will probably be self-intersecting.
   */
  insetPolygonLines: Array<Line> = [];

  /**
   * The inset polygon lines resembling an actual polygon instance (not just a sequence of lines).
   */
  insetPolygon: Polygon;

  /**
   * Each polygon line and it's offsetted inset-line resemble a rectangular polygon.
   * Array<Polygon> with 4 vertices each
   **/
  insetRectanglePolygons: Array<Polygon>;

  /**
   * The inset polygon split up into simple non-self-intersecting polygons.
   * Represented as a list of vertex-lists. Each sub-list represents a single polygon.
   */
  splitPolygons: Array<Array<Vertex>> = [];

  /**
   * The final result: all valid split-polygons. These are making up the actual polygon inset.
   * Note: list may be empty. Depending on the offset amount there is not a guaranteed offset polygon existing.
   */
  filteredSplitPolygons: Array<Array<Vertex>>;

  /**
   * Constructs a new PolygonInset instance with the underlying given polygon to work with.
   *
   * Please note that the algorithm will reverse the vertex order if the given polygon
   * is not clockwise.
   *
   * @param {Polygon} polygon - The polygon to calculate the offset for.
   */
  constructor(polygon: Polygon) {
    this.polygon = polygon;
  }

  /**
   * This is the main method.
   *
   * Call this with the required option params to compute your desired offset polygon(s).
   *
   * @param {number} options.innerPolygonOffset - The offset to use. Should be a positive number. Correct result for negative numbers are not guaranteed.
   * @param {number?} options.maxPolygonSplitDepth - (default is the number of polygon.vertices) The maximum amount of recursive stepts to simplify the complex first iteration of the offset polygon.
   * @param {number?} options.intersectionEpsilon - (default is 1.0) The epsilon to use for detecting overlapping polygons. This indicates a tolerance value, because directly adjecent polygons may have a little arithmetic intersection area.
   * @returns {Array<Array<Vertex>>} A list of vertex-lists, each one representing a simple polygon from the offset-polygons.
   */
  public computeOutputPolygons(options: IPolygonInsetOptions): Array<Array<Vertex>> {
    PolygonInset._assertPolygonIsClockwise(this.polygon.vertices);
    const maxPolygonSplitDepth = options?.maxPolygonSplitDepth ?? this.polygon.vertices.length;
    const intersectionEpsilon: number | undefined = options.intersectionEpsilon;
    this.originalPolygonLines = this.polygon.getEdges();
    this._collectInsetLines(this.originalPolygonLines, options.innerPolygonOffset);
    this._collectInsetPolygonLines(this.insetLines);
    this.insetPolygon = PolygonInset.convertToBasicInsetPolygon(this.insetPolygonLines);
    this.insetRectanglePolygons = this._collectRectangularPolygonInsets(this.originalPolygonLines, this.insetLines);
    this.splitPolygons = splitPolygonToNonIntersecting(this.insetPolygon.vertices, maxPolygonSplitDepth, true); // insideBoundsOnly

    // This method was initially meant to calculate inset-polygons only.
    // But with a simple filter we COULD also create outer offset-polygons.
    // Maybe this is a task for the future
    // console.log("DEBUG", DEBUG);
    // DEBUG("TEST");
    if (options.innerPolygonOffset === 0) {
      return [this.polygon.vertices]; // No change
    }

    // console.log("splitPolygons.length", this.splitPolygons.length);
    // Assert all polygons are clockwise!
    PolygonInset._assertAllPolygonsAreClockwise(this.splitPolygons);

    this.filteredSplitPolygons = PolygonInset._filterInnerSplitPolygonsByCoverage(
      this.splitPolygons,
      this.insetRectanglePolygons,
      intersectionEpsilon
    );
    // console.log("[0] filteredSplitPolygons.length", this.filteredSplitPolygons.length);
    this.filteredSplitPolygons = PolygonInset._filterInnerSplitPolygonsByOriginalBounds(this.filteredSplitPolygons, this.polygon);
    // console.log("[1] filteredSplitPolygons.length", this.filteredSplitPolygons.length);
    return this.filteredSplitPolygons;
  }

  /**
   * This method transforms each polygon line into a new line
   * by moving it to the inside direction of the polygon (by the given `insetAmount`).
   *
   * @param {Array<Line>} polygonLines
   * @param {number} insetAmount
   * @return {Array<Line>} The transformed lines. The result array has the same length and order as the input array.
   */
  private _collectInsetLines(polygonLines: Array<Line>, insetAmount: number): Array<Line> {
    const insetLines: Array<Line> = []; // Array<Line>
    for (var i = 0; i < polygonLines.length; i++) {
      const line = polygonLines[i];
      const perp = new Vector(line.a, line.b).perp();
      const t = insetAmount / perp.length();
      const offsetOnPerp = perp.vertAt(t);
      const diff = line.a.difference(offsetOnPerp);
      // Polygon is is clockwise order.
      // Move line inside polygon
      const movedLine = line.clone();
      movedLine.a.add(diff);
      movedLine.b.add(diff);
      insetLines.push(movedLine);
    }
    this.insetLines = insetLines;
    return insetLines;
  }

  /**
   * For a sequence of inset polygon lines get the inset polygon by detecting
   * useful intersections (by cropping or extending them).
   *
   * The returned lines resemble a new polygon.
   *
   * Please note that the returned polygon can be self-intersecting!
   *
   * @param {Array<Line>} insetLines
   * @returns {Array<Line>} The cropped or exented inset polygon lines.
   */
  private _collectInsetPolygonLines(insetLines: Array<Line>): Array<Line> {
    if (insetLines.length <= 1) {
      return [];
    }
    const insetPolygonLines: Array<Line> = [];
    // Collect first intersection at beginning :)
    const lastInsetLine: Line = insetLines[insetLines.length - 1];
    const firstInsetLine: Line = insetLines[0];
    let lastIntersectionPoint = lastInsetLine.intersection(firstInsetLine); // Must not be null
    for (var i = 0; i < insetLines.length; i++) {
      const insetLine: Line = insetLines[i];

      const nextInsetLine: Line = insetLines[(i + 1) % insetLines.length];
      // Find desired intersection
      const intersection: Vertex | null = insetLine.intersection(nextInsetLine);
      if (intersection == null) {
        console.warn("[collectInsetPolygon] WARN intersection line must not be null", i, nextInsetLine);
      } else {
        // By construction they MUST have any non-null intersection!
        if (lastIntersectionPoint != null) {
          const resultLine: Line = new Line(lastIntersectionPoint, intersection);
          insetPolygonLines.push(resultLine);
        }
      }
      lastIntersectionPoint = intersection;
    }
    // Store intermediate result for later retrieval.
    this.insetPolygonLines = insetPolygonLines;
    return insetPolygonLines;
  }

  /**
   * Converts two lists (same length) of original polygon lines and inset lines (interpreted as
   * pairs) to a list of rectangular polyons.
   *
   * @static
   * @param {Array<Line>} originalPolygonLines
   * @param {Array<Line>} insetLines
   * @returns {Array<Polygon>} A list of rectangular polygons; each returned polyon has exactly four vertices.
   */
  private _collectRectangularPolygonInsets(originalPolygonLines: Array<Line>, insetLines: Array<Line>): Array<Polygon> {
    // Convert to rectangle polygon
    const insetRectanglePolygons: Array<Polygon> = originalPolygonLines.map((polygonLine, index) => {
      const rectPolygon: Polygon = new Polygon([], false);
      // Add in original order
      rectPolygon.vertices.push(polygonLine.a.clone());
      rectPolygon.vertices.push(polygonLine.b.clone());
      // Add in reverse order
      const insetLine: Line = insetLines[index];
      rectPolygon.vertices.push(insetLine.b.clone());
      rectPolygon.vertices.push(insetLine.a.clone());
      return rectPolygon;
    });
    return insetRectanglePolygons;
  }

  /**
   * Converts a sequence of (hopefully adjacent) lines to a polygon by using all second line vertices `b`.
   *
   * @static
   * @param insetPolygonLines
   * @returns
   */
  private static convertToBasicInsetPolygon(insetPolygonLines: Array<Line>): Polygon {
    const insetPolygon = new Polygon([], false);
    insetPolygonLines.forEach((insetLine: Line): void => {
      insetPolygon.vertices.push(insetLine.a);
    });
    return insetPolygon;
  }

  /**
   * Filter split polygons: only keep those whose vertices are all contained inside the original polygon.
   * Reason: scaling too much will result in excessive translation beyond the opposite bounds of the polygon (like more than 200% of possible insetting).
   *
   * @param {Array<Array<Vertex>>} splitPolygonsVertices
   * @param {Polygon} originalPolygon
   * @return {Array<Array<Vertex>>} The filtered polygon list.
   */
  private static _filterInnerSplitPolygonsByOriginalBounds(
    splitPolygonsVertices: Array<Array<Vertex>>,
    originalPolygon: Polygon
  ) {
    return splitPolygonsVertices.filter((splitPolyVerts: Array<Vertex>, _splitPolyIndex: number): boolean => {
      return splitPolyVerts.every((splitPVert: Vertex): boolean => {
        return originalPolygon.containsVert(splitPVert);
      });
    });
  }

  /**
   * Filter split polygons: only keep those that do not (signifiantly) interset with any rectangles.
   *
   * @static
   * @param {Array<Array<Vertex>>} splitPolygonsVertices
   * @param {Array<Polygon>} insetRectanglePolygons
   * @param {number?=1.0} intersectionEpsilon - (optional, default is 1.0) A epsislon to define a tolerance for checking if two polygons intersect.
   */
  private static _filterInnerSplitPolygonsByCoverage(
    splitPolygonsVertices: Array<Array<Vertex>>,
    insetRectanglePolygons: Array<Polygon>,
    intersectionEpsilon?: number
  ) {
    // TEST: Add some jitter
    // splitPolygonsVertices.forEach(split => {
    //   split.forEach(vert => {
    //     vert.x += (0.5 - Math.random()) * 0.01;
    //     vert.y += (0.5 - Math.random()) * 0.01;
    //   });
    // });

    splitPolygonsVertices.forEach((split, index) => {
      const isCW: boolean = Polygon.utils.isClockwise(split);
      if (!isCW) {
        console.log("split is not isClockwise!", index, isCW);
      }
    });
    insetRectanglePolygons.forEach((rect, index) => {
      const isCW: boolean = rect.isClockwise();
      if (!isCW) {
        console.log("rect is not isClockwise!", index, isCW);
      }
    });

    const eps: number =
      intersectionEpsilon === undefined || typeof intersectionEpsilon === "undefined" ? 1.0 : intersectionEpsilon;
    return splitPolygonsVertices.filter((splitPolyVerts: Vertex[], _splitPolyIndex: number) => {
      const intersectsWithAnyRect = insetRectanglePolygons.some((rectanglePoly: Polygon, _rectanglePolyIndex: number) => {
        // const intersectionVerts: XYCoords[] = sutherlandHodgman(splitPolyVerts, rectanglePoly.vertices);
        const intersectionVerts: XYCoords[] = sutherlandHodgman(rectanglePoly.vertices, splitPolyVerts);

        // var intersection = GreinerHorman.intersection(sourcePolygon.vertices, clipPolygon.vertices);
        // const uniqueIntersectionVerts = clearDuplicateVertices(intersectionVerts);
        const intersectionAreaSize: number = Polygon.utils.area(intersectionVerts);
        if (intersectionAreaSize >= eps) {
          console.log(
            "intersectionAreaSize",
            intersectionAreaSize,
            "_splitPolyIndex",
            _splitPolyIndex,
            "_rectanglePolyIndex",
            _rectanglePolyIndex,
            "intersectionVerts",
            intersectionVerts
            // "uniqueIntersectionVerts",
            // uniqueIntersectionVerts
          );
        }
        return intersectionAreaSize >= eps;
      });

      return !intersectsWithAnyRect;
    });
  }

  private static _assertAllPolygonsAreClockwise(polygons: Array<Vertex[]>) {
    polygons.forEach((polygonVerts: Vertex[], _polyIndex: number) => {
      // if (!Polygon.utils.isClockwise(polygonVerts)) {
      //   polygonVerts.reverse(); // Attention: this happens in-place (Array.reverse is destructive!)
      // }
      PolygonInset._assertPolygonIsClockwise(polygonVerts);
    });
  }

  private static _assertPolygonIsClockwise(polygonVerts: Vertex[]) {
    if (!Polygon.utils.isClockwise(polygonVerts)) {
      polygonVerts.reverse(); // Attention: this happens in-place (Array.reverse is destructive!)
    }
  }
}
