/**
 * Calculate the inset of any non-self-overlapping polygon.
 *
 * The polygon may be
 *  - convex or non-convex
 *  - self-intersecting
 *
 * The algorithms will
 *  - first construct a general offset polygon which may be corrupt due to ouf-of-bounds or in illegal-area problems.
 *  - then dissect the possibly self-intersecting inset polygon into separate simple polygons.
 *  - then detect for each if it's out of bounds or in some illegal area.
 *  - keeping only the valid ones.
 *
 * @required sutherlandHodgman
 * @required splitPolygonToNonIntersecting
 *
 * @author   Ikaros Kappler
 * @date     2024-11-04 Ported the script to a class.
 * @modified 2024-12-02 Ported to Typescript.
 */
import { Line } from "../../Line";
import { Polygon } from "../../Polygon";
import { Vector } from "../../Vector";
import { splitPolygonToNonIntersecting } from "./splitPolygonToNonIntersecting";
import { sutherlandHodgman } from "./sutherlandHodgman";
export class PolygonInset {
    /**
     * Constructs a new PolygonInset instance with the underlying given polygon to work with.
     *
     * Please note that the algorithm will reverse the vertex order if the given polygon
     * is not clockwise.
     *
     * @param {Polygon} polygon - The polygon to calculate the offset for.
     */
    constructor(polygon) {
        /**
         * The original polygon as a sequence of line objects. This is easier to use than a list of points.
         */
        this.originalPolygonLines = [];
        /**
         * The simple inset lines, directly generated by offsetting the original polygon lines by the given amount.
         */
        this.insetLines = [];
        /**
         * The cropped inset lines that makes up the first direct iteration of the inset polygon.
         * This one will probably be self-intersecting.
         */
        this.insetPolygonLines = [];
        /**
         * The inset polygon split up into simple non-self-intersecting polygons.
         * Represented as a list of vertex-lists. Each sub-list represents a single polygon.
         */
        this.splitPolygons = [];
        this.polygon = polygon;
    }
    /**
     * This is the main method.
     *
     * Call this with the required option params to compute your desired offset polygon(s).
     *
     * @param {number} options.innerPolygonOffset - The offset to use. Should be a positive number. Correct result for negative numbers are not guaranteed.
     * @param {number?} options.maxPolygonSplitDepth - (default is the number of polygon.vertices) The maximum amount of recursive stepts to simplify the complex first iteration of the offset polygon.
     * @param {number?} options.intersectionEpsilon - (default is 1.0) The epsilon to use for detecting overlapping polygons. This indicates a tolerance value, because directly adjecent polygons may have a little arithmetic intersection area.
     * @returns {Array<Array<Vertex>>} A list of vertex-lists, each one representing a simple polygon from the offset-polygons.
     */
    computeOutputPolygons(options) {
        var _a;
        PolygonInset._assertPolygonIsClockwise(this.polygon.vertices);
        const maxPolygonSplitDepth = (_a = options === null || options === void 0 ? void 0 : options.maxPolygonSplitDepth) !== null && _a !== void 0 ? _a : this.polygon.vertices.length;
        const intersectionEpsilon = options.intersectionEpsilon;
        this.originalPolygonLines = this.polygon.getEdges();
        this._collectInsetLines(this.originalPolygonLines, options.innerPolygonOffset);
        this._collectInsetPolygonLines(this.insetLines);
        this.insetPolygon = PolygonInset.convertToBasicInsetPolygon(this.insetPolygonLines);
        this.insetRectanglePolygons = this._collectRectangularPolygonInsets(this.originalPolygonLines, this.insetLines);
        this.splitPolygons = splitPolygonToNonIntersecting(this.insetPolygon.vertices, maxPolygonSplitDepth, true); // insideBoundsOnly
        // This method was initially meant to calculate inset-polygons only.
        // But with a simple filter we COULD also create outer offset-polygons.
        // Maybe this is a task for the future
        // console.log("DEBUG", DEBUG);
        // DEBUG("TEST");
        if (options.innerPolygonOffset === 0) {
            return [this.polygon.vertices]; // No change
        }
        // console.log("splitPolygons.length", this.splitPolygons.length);
        // Assert all polygons are clockwise!
        PolygonInset._assertAllPolygonsAreClockwise(this.splitPolygons);
        this.filteredSplitPolygons = PolygonInset._filterInnerSplitPolygonsByCoverage(this.splitPolygons, this.insetRectanglePolygons, intersectionEpsilon);
        // console.log("[0] filteredSplitPolygons.length", this.filteredSplitPolygons.length);
        this.filteredSplitPolygons = PolygonInset._filterInnerSplitPolygonsByOriginalBounds(this.filteredSplitPolygons, this.polygon);
        // console.log("[1] filteredSplitPolygons.length", this.filteredSplitPolygons.length);
        return this.filteredSplitPolygons;
    }
    /**
     * This method transforms each polygon line into a new line
     * by moving it to the inside direction of the polygon (by the given `insetAmount`).
     *
     * @param {Array<Line>} polygonLines
     * @param {number} insetAmount
     * @return {Array<Line>} The transformed lines. The result array has the same length and order as the input array.
     */
    _collectInsetLines(polygonLines, insetAmount) {
        const insetLines = []; // Array<Line>
        for (var i = 0; i < polygonLines.length; i++) {
            const line = polygonLines[i];
            const perp = new Vector(line.a, line.b).perp();
            const t = insetAmount / perp.length();
            const offsetOnPerp = perp.vertAt(t);
            const diff = line.a.difference(offsetOnPerp);
            // Polygon is is clockwise order.
            // Move line inside polygon
            const movedLine = line.clone();
            movedLine.a.add(diff);
            movedLine.b.add(diff);
            insetLines.push(movedLine);
        }
        this.insetLines = insetLines;
        return insetLines;
    }
    /**
     * For a sequence of inset polygon lines get the inset polygon by detecting
     * useful intersections (by cropping or extending them).
     *
     * The returned lines resemble a new polygon.
     *
     * Please note that the returned polygon can be self-intersecting!
     *
     * @param {Array<Line>} insetLines
     * @returns {Array<Line>} The cropped or exented inset polygon lines.
     */
    _collectInsetPolygonLines(insetLines) {
        if (insetLines.length <= 1) {
            return [];
        }
        const insetPolygonLines = [];
        // Collect first intersection at beginning :)
        const lastInsetLine = insetLines[insetLines.length - 1];
        const firstInsetLine = insetLines[0];
        let lastIntersectionPoint = lastInsetLine.intersection(firstInsetLine); // Must not be null
        for (var i = 0; i < insetLines.length; i++) {
            const insetLine = insetLines[i];
            const nextInsetLine = insetLines[(i + 1) % insetLines.length];
            // Find desired intersection
            const intersection = insetLine.intersection(nextInsetLine);
            if (intersection == null) {
                console.warn("[collectInsetPolygon] WARN intersection line must not be null", i, nextInsetLine);
            }
            else {
                // By construction they MUST have any non-null intersection!
                if (lastIntersectionPoint != null) {
                    const resultLine = new Line(lastIntersectionPoint, intersection);
                    insetPolygonLines.push(resultLine);
                }
            }
            lastIntersectionPoint = intersection;
        }
        // Store intermediate result for later retrieval.
        this.insetPolygonLines = insetPolygonLines;
        return insetPolygonLines;
    }
    /**
     * Converts two lists (same length) of original polygon lines and inset lines (interpreted as
     * pairs) to a list of rectangular polyons.
     *
     * @static
     * @param {Array<Line>} originalPolygonLines
     * @param {Array<Line>} insetLines
     * @returns {Array<Polygon>} A list of rectangular polygons; each returned polyon has exactly four vertices.
     */
    _collectRectangularPolygonInsets(originalPolygonLines, insetLines) {
        // Convert to rectangle polygon
        const insetRectanglePolygons = originalPolygonLines.map((polygonLine, index) => {
            const rectPolygon = new Polygon([], false);
            // Add in original order
            rectPolygon.vertices.push(polygonLine.a.clone());
            rectPolygon.vertices.push(polygonLine.b.clone());
            // Add in reverse order
            const insetLine = insetLines[index];
            rectPolygon.vertices.push(insetLine.b.clone());
            rectPolygon.vertices.push(insetLine.a.clone());
            return rectPolygon;
        });
        return insetRectanglePolygons;
    }
    /**
     * Converts a sequence of (hopefully adjacent) lines to a polygon by using all second line vertices `b`.
     *
     * @static
     * @param insetPolygonLines
     * @returns
     */
    static convertToBasicInsetPolygon(insetPolygonLines) {
        const insetPolygon = new Polygon([], false);
        insetPolygonLines.forEach((insetLine) => {
            insetPolygon.vertices.push(insetLine.a);
        });
        return insetPolygon;
    }
    /**
     * Filter split polygons: only keep those whose vertices are all contained inside the original polygon.
     * Reason: scaling too much will result in excessive translation beyond the opposite bounds of the polygon (like more than 200% of possible insetting).
     *
     * @param {Array<Array<Vertex>>} splitPolygonsVertices
     * @param {Polygon} originalPolygon
     * @return {Array<Array<Vertex>>} The filtered polygon list.
     */
    static _filterInnerSplitPolygonsByOriginalBounds(splitPolygonsVertices, originalPolygon) {
        return splitPolygonsVertices.filter((splitPolyVerts, _splitPolyIndex) => {
            return splitPolyVerts.every((splitPVert) => {
                return originalPolygon.containsVert(splitPVert);
            });
        });
    }
    /**
     * Filter split polygons: only keep those that do not (signifiantly) interset with any rectangles.
     *
     * @static
     * @param {Array<Array<Vertex>>} splitPolygonsVertices
     * @param {Array<Polygon>} insetRectanglePolygons
     * @param {number?=1.0} intersectionEpsilon - (optional, default is 1.0) A epsislon to define a tolerance for checking if two polygons intersect.
     */
    static _filterInnerSplitPolygonsByCoverage(splitPolygonsVertices, insetRectanglePolygons, intersectionEpsilon) {
        // TEST: Add some jitter
        // splitPolygonsVertices.forEach(split => {
        //   split.forEach(vert => {
        //     vert.x += (0.5 - Math.random()) * 0.01;
        //     vert.y += (0.5 - Math.random()) * 0.01;
        //   });
        // });
        splitPolygonsVertices.forEach((split, index) => {
            const isCW = Polygon.utils.isClockwise(split);
            if (!isCW) {
                console.log("split is not isClockwise!", index, isCW);
            }
        });
        insetRectanglePolygons.forEach((rect, index) => {
            const isCW = rect.isClockwise();
            if (!isCW) {
                console.log("rect is not isClockwise!", index, isCW);
            }
        });
        const eps = intersectionEpsilon === undefined || typeof intersectionEpsilon === "undefined" ? 1.0 : intersectionEpsilon;
        return splitPolygonsVertices.filter((splitPolyVerts, _splitPolyIndex) => {
            const intersectsWithAnyRect = insetRectanglePolygons.some((rectanglePoly, _rectanglePolyIndex) => {
                // const intersectionVerts: XYCoords[] = sutherlandHodgman(splitPolyVerts, rectanglePoly.vertices);
                const intersectionVerts = sutherlandHodgman(rectanglePoly.vertices, splitPolyVerts);
                // var intersection = GreinerHorman.intersection(sourcePolygon.vertices, clipPolygon.vertices);
                // const uniqueIntersectionVerts = clearDuplicateVertices(intersectionVerts);
                const intersectionAreaSize = Polygon.utils.area(intersectionVerts);
                if (intersectionAreaSize >= eps) {
                    console.log("intersectionAreaSize", intersectionAreaSize, "_splitPolyIndex", _splitPolyIndex, "_rectanglePolyIndex", _rectanglePolyIndex, "intersectionVerts", intersectionVerts
                    // "uniqueIntersectionVerts",
                    // uniqueIntersectionVerts
                    );
                }
                return intersectionAreaSize >= eps;
            });
            return !intersectsWithAnyRect;
        });
    }
    static _assertAllPolygonsAreClockwise(polygons) {
        polygons.forEach((polygonVerts, _polyIndex) => {
            // if (!Polygon.utils.isClockwise(polygonVerts)) {
            //   polygonVerts.reverse(); // Attention: this happens in-place (Array.reverse is destructive!)
            // }
            PolygonInset._assertPolygonIsClockwise(polygonVerts);
        });
    }
    static _assertPolygonIsClockwise(polygonVerts) {
        if (!Polygon.utils.isClockwise(polygonVerts)) {
            polygonVerts.reverse(); // Attention: this happens in-place (Array.reverse is destructive!)
        }
    }
}
//# sourceMappingURL=PolygonInset.js.map