"use strict";
/**
 * Calculate the inset of any non-self-overlapping polygon.
 *
 * The polygon may be
 *  - convex or non-convex
 *  - self-intersecting
 *
 * The algorithms will
 *  - first construct a general offset polygon which may be corrupt due to ouf-of-bounds or in illegal-area problems.
 *  - then dissect the possibly self-intersecting inset polygon into separate simple polygons.
 *  - then detect for each if it's out of bounds or in some illegal area.
 *  - keeping only the valid ones.
 *
 * @required sutherlandHodgman
 * @required splitPolygonToNonIntersecting
 *
 * @author   Ikaros Kappler
 * @date     2024-11-04 Ported the script to a class.
 * @modified 2024-12-02 Ported to Typescript.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.PolygonInset = void 0;
var Line_1 = require("../../Line");
var Polygon_1 = require("../../Polygon");
var Vector_1 = require("../../Vector");
var splitPolygonToNonIntersecting_1 = require("./splitPolygonToNonIntersecting");
var sutherlandHodgman_1 = require("./sutherlandHodgman");
var PolygonInset = /** @class */ (function () {
    /**
     * Constructs a new PolygonInset instance with the underlying given polygon to work with.
     * @param {Polygon} polygon - The polygon to calculate the offset for.
     */
    function PolygonInset(polygon) {
        /**
         * The original polygon as a sequence of line objects. This is easier to use than a list of points.
         */
        this.originalPolygonLines = [];
        /**
         * The simple inset lines, directly generated by offsetting the original polygon lines by the given amount.
         */
        this.insetLines = [];
        /**
         * The cropped inset lines that makes up the first direct iteration of the inset polygon.
         * This one will probably be self-intersecting.
         */
        this.insetPolygonLines = [];
        /**
         * The inset polygon split up into simple non-self-intersecting polygons.
         * Represented as a list of vertex-lists. Each sub-list represents a single polygon.
         */
        this.splitPolygons = [];
        this.polygon = polygon;
    }
    /**
     * This is the main method.
     *
     * Call this with the required option params to compute your desired offset polygon(s).
     *
     * @param {number} options.innerPolygonOffset - The offset to use. Should be a positive number. Correct result for negative numbers are not guaranteed.
     * @param {number?} options.maxPolygonSplitDepth - (default is the number of polygon.vertices) The maximum amount of recursive stepts to simplify the complex first iteration of the offset polygon.
     * @param {number?} options.intersectionEpsilon - (default is 1.0) The epsilon to use for detecting overlapping polygons. This indicates a tolerance value, because directly adjecent polygons may have a little arithmetic intersection area.
     * @returns {Array<Array<Vertex>>} A list of vertex-lists, each one representing a simple polygon from the offset-polygons.
     */
    PolygonInset.prototype.computeOutputPolygons = function (options) {
        var _a;
        var maxPolygonSplitDepth = (_a = options === null || options === void 0 ? void 0 : options.maxPolygonSplitDepth) !== null && _a !== void 0 ? _a : this.polygon.vertices.length;
        var intersectionEpsilon = options.intersectionEpsilon;
        this.originalPolygonLines = this.polygon.getEdges();
        this._collectInsetLines(this.originalPolygonLines, options.innerPolygonOffset);
        this._collectInsetPolygonLines(this.insetLines);
        this.insetPolygon = PolygonInset.convertToBasicInsetPolygon(this.insetPolygonLines);
        this.insetRectanglePolygons = this._collectRectangularPolygonInsets(this.originalPolygonLines, this.insetLines);
        this.splitPolygons = (0, splitPolygonToNonIntersecting_1.splitPolygonToNonIntersecting)(this.insetPolygon.vertices, maxPolygonSplitDepth, true); // insideBoundsOnly
        // This method was initially meant to calculate inset-polygons only.
        // But with a simple filter we COULD also create outer offset-polygons.
        // Maybe this is a task for the future
        if (options.innerPolygonOffset === 0) {
            return [this.polygon.vertices]; // No change
        }
        this.filteredSplitPolygons = PolygonInset._filterInnerSplitPolygonsByCoverage(this.splitPolygons, this.insetRectanglePolygons, intersectionEpsilon);
        this.filteredSplitPolygons = PolygonInset._filterInnerSplitPolygonsByOriginalBounds(this.filteredSplitPolygons, this.polygon);
        return this.filteredSplitPolygons;
    };
    /**
     * This method transforms each polygon line into a new line
     * by moving it to the inside direction of the polygon (by the given `insetAmount`).
     *
     * @param {Array<Line>} polygonLines
     * @param {number} insetAmount
     * @return {Array<Line>} The transformed lines. The result array has the same length and order as the input array.
     */
    PolygonInset.prototype._collectInsetLines = function (polygonLines, insetAmount) {
        var insetLines = []; // Array<Line>
        for (var i = 0; i < polygonLines.length; i++) {
            var line = polygonLines[i];
            var perp = new Vector_1.Vector(line.a, line.b).perp();
            var t = insetAmount / perp.length();
            var offsetOnPerp = perp.vertAt(t);
            var diff = line.a.difference(offsetOnPerp);
            // Polygon is is clockwise order.
            // Move line inside polygon
            var movedLine = line.clone();
            movedLine.a.add(diff);
            movedLine.b.add(diff);
            insetLines.push(movedLine);
        }
        this.insetLines = insetLines;
        return insetLines;
    };
    /**
     * For a sequence of inset polygon lines get the inset polygon by detecting
     * useful intersections (by cropping or extending them).
     *
     * The returned lines resemble a new polygon.
     *
     * Please note that the returned polygon can be self-intersecting!
     *
     * @param {Array<Line>} insetLines
     * @returns {Array<Line>} The cropped or exented inset polygon lines.
     */
    PolygonInset.prototype._collectInsetPolygonLines = function (insetLines) {
        if (insetLines.length <= 1) {
            return [];
        }
        var insetPolygonLines = [];
        // Collect first intersection at beginning :)
        var lastInsetLine = insetLines[insetLines.length - 1];
        var firstInsetLine = insetLines[0];
        var lastIntersectionPoint = lastInsetLine.intersection(firstInsetLine); // Must not be null
        for (var i = 0; i < insetLines.length; i++) {
            var insetLine = insetLines[i];
            var nextInsetLine = insetLines[(i + 1) % insetLines.length];
            // Find desired intersection
            var intersection = insetLine.intersection(nextInsetLine);
            if (intersection == null) {
                console.warn("[collectInsetPolygon] WARN intersection line must not be null", i, nextInsetLine);
            }
            else {
                // By construction they MUST have any non-null intersection!
                if (lastIntersectionPoint != null) {
                    var resultLine = new Line_1.Line(lastIntersectionPoint, intersection);
                    insetPolygonLines.push(resultLine);
                }
            }
            lastIntersectionPoint = intersection;
        }
        // Store intermediate result for later retrieval.
        this.insetPolygonLines = insetPolygonLines;
        return insetPolygonLines;
    };
    /**
     * Converts two lists (same length) of original polygon lines and inset lines (interpreted as
     * pairs) to a list of rectangular polyons.
     *
     * @static
     * @param {Array<Line>} originalPolygonLines
     * @param {Array<Line>} insetLines
     * @returns {Array<Polygon>} A list of rectangular polygons; each returned polyon has exactly four vertices.
     */
    PolygonInset.prototype._collectRectangularPolygonInsets = function (originalPolygonLines, insetLines) {
        // Convert to rectangle polygon
        var insetRectanglePolygons = originalPolygonLines.map(function (polygonLine, index) {
            var rectPolygon = new Polygon_1.Polygon([], false);
            // Add in original order
            rectPolygon.vertices.push(polygonLine.a.clone());
            rectPolygon.vertices.push(polygonLine.b.clone());
            // Add in reverse order
            var insetLine = insetLines[index];
            rectPolygon.vertices.push(insetLine.b.clone());
            rectPolygon.vertices.push(insetLine.a.clone());
            return rectPolygon;
        });
        return insetRectanglePolygons;
    };
    /**
     * Converts a sequence of (hopefully adjacent) lines to a polygon by using all second line vertices `b`.
     *
     * @static
     * @param insetPolygonLines
     * @returns
     */
    PolygonInset.convertToBasicInsetPolygon = function (insetPolygonLines) {
        var insetPolygon = new Polygon_1.Polygon([], false);
        insetPolygonLines.forEach(function (insetLine) {
            insetPolygon.vertices.push(insetLine.a);
        });
        return insetPolygon;
    };
    /**
     * Filter split polygons: only keep those whose vertices are all contained inside the original polygon.
     * Reason: scaling too much will result in excessive translation beyond the opposite bounds of the polygon (like more than 200% of possible insetting).
     *
     * @param {Array<Array<Vertex>>} splitPolygonsVertices
     * @param {Polygon} originalPolygon
     * @return {Array<Array<Vertex>>} The filtered polygon list.
     */
    PolygonInset._filterInnerSplitPolygonsByOriginalBounds = function (splitPolygonsVertices, originalPolygon) {
        return splitPolygonsVertices.filter(function (splitPolyVerts, _splitPolyIndex) {
            return splitPolyVerts.every(function (splitPVert) {
                return originalPolygon.containsVert(splitPVert);
            });
        });
    };
    /**
     * Filter split polygons: only keep those that do not (signifiantly) interset with any rectangles.
     *
     * @static
     * @param {Array<Array<Vertex>>} splitPolygonsVertices
     * @param {Array<Polygon>} insetRectanglePolygons
     * @param {number?=1.0} intersectionEpsilon - (optional, default is 1.0) A epsislon to define a tolerance for checking if two polygons intersect.
     */
    PolygonInset._filterInnerSplitPolygonsByCoverage = function (splitPolygonsVertices, insetRectanglePolygons, intersectionEpsilon) {
        var eps = intersectionEpsilon === undefined || typeof intersectionEpsilon === "undefined" ? 1.0 : intersectionEpsilon;
        return splitPolygonsVertices.filter(function (splitPolyVerts, _splitPolyIndex) {
            var intersectsWithAnyRect = insetRectanglePolygons.some(function (rectanglePoly, _rectanglePolyIndex) {
                var intersectionVerts = (0, sutherlandHodgman_1.sutherlandHodgman)(splitPolyVerts, rectanglePoly.vertices);
                var intersectionAreaSize = Polygon_1.Polygon.utils.area(intersectionVerts);
                return intersectionAreaSize >= eps;
            });
            return !intersectsWithAnyRect;
        });
    };
    return PolygonInset;
}());
exports.PolygonInset = PolygonInset;
//# sourceMappingURL=PolygonInset.js.map